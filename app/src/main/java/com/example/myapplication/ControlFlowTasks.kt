import kotlin.math.pow

/**
 * Задание 1. Напишите программу, которая принимает целое число от пользователя и проверяет,
 * является ли оно положительным, отрицательным или нулем.
 * Используйте различные варианты условных операторов (if, if-else, when).
 */
fun controlFlowTask1a() { //  использование when
    val input = readln().toInt() // получение строки из стандартного ввода, приведение к Integer
    when {
        input > 0 -> println("Введено положительное число")
        input < 0 -> println("Введено отрицательное число")
        else -> println("Введен 0")
    }
}

fun controlFlowTask1b() { // использование if-else ladder
    val input = readln().toInt() // получение строки из стандартного ввода, приведение к Integer
    if (input > 0) {
        println("Введено положительное число")
    } else if (input == 0) {
        println("Введен 0")
    } else {
        println("Введено отрицательное число")
    }
}

/**
 * Задание 2. Создайте массив из 10 чисел.
 * a. Напишите цикл for, который будет выводить каждое число и его квадрат.
 * После этого напишите цикл while, который будет выводить каждое число и его куб.
 */
fun controlFlowTask2a() {
    // изменила с Int на Double, тк pow() нет у Int
    val doubleArray = doubleArrayOf(1.0, 1.0, 2.0, 3.0, 5.0, 8.0, 13.0, 21.0, 34.0, 55.0) // массив
    for (i in doubleArray) { // проходим по всем элементам и выводим квадрат
        println("Число: $i, квадрат: ${i.pow(2)}")
    }

    // проходим по всем элементам (обращение по индексу i)
    var i = 0
    while (i < doubleArray.size) {
        println("Число: ${doubleArray[i]}, куб: ${doubleArray[i].pow(3)}")
        i++
    }
}

/**
 * Задание 2.
 * b. Используйте функцию repeat для вывода строки “Привет, мир!” 10 раз.
 */
fun controlFlowTask2b() {
    repeat(10) {
        println("Привет, мир!")
    }
}

/**
 * Задание 3.
 *  a. Напишите функцию, которая принимает массив чисел и возвращает сумму только тех чисел,
 * которые больше 10. Если обнаруживается число меньше 0, функция должна немедленно
 * прекратить обработку и вернуть текущую сумму (используйте return).
 */
fun task3aSumFunction(array: Array<Int>): Int { // сама функция для суммирования
    var sum = 0
    for (i in array) { // проходим по элементам массива
        if (i < 0) { // если элемент < 0, возвращаем текущую сумму
            return sum
        }
        if (i > 10) { // если элемент > 10, добавляем его к общей сумме
            sum += i
        }
    }
    return sum // возвращаем сумму
}

fun controlFlowTask3a() { // проверка вызова функции для третьго задания
    println(task3aSumFunction(arrayOf(10, 11, 12, -1, 3, 11, 5, 9)))
}

/**
 * Задание 3.
 * b. Напишите цикл, который выводит числа от 1 до 10,
 * но пропускает числа 3 и 7 (используйте continue).
 */
fun controlFlowTask3b() {
    for (i in 1..10) { // проходим по значениям i от 1 до 10
        if (i == 3 || i == 7) // если i равно 3 или 7, то переходим к следующей итерации цикла
            continue
        println(i) // вывод текущего значения i
    }
}

/**
 * Задание 3.
 * c. Вам дана двумерная матрица целых чисел и целевое число. Напишите программу на Kotlin,
 * чтобы искать целевое число в матрице.
 * Если целевое число найдено, выведите его позицию (строка и столбец)
 * и завершите выполнение циклов; если не найдено, выведите сообщение об этом. (используйте break).
 * Целевое значение должно вводиться пользователем.
 *
 */
fun controlFlowTask3c() {
    val matrix = arrayOf(
        arrayOf(1, 2, 3, 4, 5),
        arrayOf(6, 7, 8, 9, 10),
        arrayOf(11, 12, 13, 14, 15),
        arrayOf(16, 17, 18, 19, 20),
        arrayOf(21, 22, 23, 24, 25)
    )
    println("Введите целевое число:")
    val input = readln().toInt() // получение строки из стандартного ввода и преобразование к Int

    label@ for (i in matrix.indices) {
        for (j in matrix[i].indices) {
            if (matrix[i][j] == input) { // если значение найдено, то выводим позицию
                println("Строка = $i, Столбец = $j")
                break@label // выход из обоих циклов
            }
            // если i и j равны размерам матрицы - 1, а цикл еще не завершился, значит, число не было найдено
            if (i == matrix.lastIndex && j == matrix[i].lastIndex)
                println("Число не найдено")
        }
    }
}

// второй вариант: с использованием return вместо break
fun controlFlowTask3c1() {
    val matrix = arrayOf(
        arrayOf(1, 2, 3, 4, 5),
        arrayOf(6, 7, 8, 9, 10),
        arrayOf(11, 12, 13, 14, 15),
        arrayOf(16, 17, 18, 19, 20),
        arrayOf(21, 22, 23, 24, 25)
    )
    println("Введите целевое число:")
    val input = readln().toInt() // получение строки из стандартного ввода и преобразование к Int

    for (i in matrix.indices) {
        for (j in matrix[i].indices) {
            if (matrix[i][j] == input) { // если значение найдено, то выводим позицию
                println("Строка = $i, Столбец = $j")
                return // выход из обоих циклов
            }
            // если i и j равны размерам матрицы - 1, а цикл еще не завершился, значит, число не было найдено
            if (i == matrix.lastIndex && j == matrix[i].lastIndex)
                println("Число не найдено")
        }
    }
}

/**
 * Задание 4.
 * a. Напишите программу, которая просит пользователя ввести целое число.
 * Если пользователь вводит что-то другое, отлавливайте исключение и
 * выводите сообщение об ошибке. Блок finally должен выводить сообщение “Конец программы”.
 */
fun controlFlowTask4a() {
    println("Введите целое число:")
    val input = readln() // получение строки из стандартного ввода
    try { // пробуем преобразовать строку к числу
        val number = input.toInt()
        println("Введено число $number")
    } catch (e: NumberFormatException) { // если введено было не число, получим исключение
        println("Некорректный ввод")
    } finally {
        println("Конец программы")
    }
}

/**
 * Задание 4.
 * b. Создайте ситуацию, где может возникнуть исключение
 * (например, обращение к несуществующему элементу массива или деление на ноль),
 * и обработайте это исключение, выводя стек вызовов.
 */
fun controlFlowTask4b() {
    try {
        val array = arrayOf(1, 2, 3) // массив из 3 элементов
        println(array[3]) // обращение к несуществующему элементу -> получаем исключение
    } catch (e: IndexOutOfBoundsException) {
        e.printStackTrace() // вывод стека вызовов исключения
    }
}